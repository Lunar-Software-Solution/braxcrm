import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import type { Ticket, TicketInsert, TicketUpdate, TicketStatus, TicketWithDetails, TicketPriority } from '@/types/tickets';
import type { EntityTable } from '@/types/activities';
import { entityTableLabels } from '@/types/activities';

// Helper to fetch entity name based on entity_table and entity_id
async function fetchEntityName(entityTable: string, entityId: string): Promise<string> {
  const validTables = [
    'people', 'affiliates', 'vigile_partners', 'brax_distributors',
    'product_suppliers', 'services_suppliers', 'corporate_management',
    'personal_contacts', 'subscription_suppliers', 'marketing_sources',
    'merchant_accounts', 'logistic_suppliers'
  ];
  
  if (!validTables.includes(entityTable)) {
    return 'Unknown';
  }

  const { data, error } = await supabase
    .from(entityTable as EntityTable)
    .select('name')
    .eq('id', entityId)
    .single();
  
  if (error || !data) return 'Unknown';
  return data.name;
}

export function useTickets(filters?: {
  entityTable?: string;
  entityId?: string;
  status?: TicketStatus[];
  priority?: string[];
  assignedTo?: string;
  search?: string;
}) {
  return useQuery({
    queryKey: ['tickets', filters],
    queryFn: async (): Promise<TicketWithDetails[]> => {
      let query = supabase
        .from('tickets')
        .select('*')
        .order('created_at', { ascending: false });

      if (filters?.entityTable) {
        query = query.eq('entity_table', filters.entityTable);
      }
      if (filters?.entityId) {
        query = query.eq('entity_id', filters.entityId);
      }
      if (filters?.status && filters.status.length > 0) {
        query = query.in('status', filters.status);
      }
      if (filters?.priority && filters.priority.length > 0) {
        query = query.in('priority', filters.priority as TicketPriority[]);
      }
      if (filters?.assignedTo) {
        query = query.eq('assigned_to', filters.assignedTo);
      }
      if (filters?.search) {
        query = query.or(`title.ilike.%${filters.search}%,ticket_number.ilike.%${filters.search}%`);
      }

      const { data, error } = await query;
      if (error) throw error;

      // Fetch entity names and assigned user info
      const ticketsWithDetails: TicketWithDetails[] = await Promise.all(
        (data || []).map(async (ticket) => {
          const entityName = await fetchEntityName(ticket.entity_table, ticket.entity_id);
          
          let assignedUser = null;
          if (ticket.assigned_to) {
            const { data: profile } = await supabase
              .from('profiles')
              .select('display_name, email')
              .eq('user_id', ticket.assigned_to)
              .single();
            assignedUser = profile;
          }

          return {
            ...ticket,
            entity_name: entityName,
            assigned_user: assignedUser,
          } as TicketWithDetails;
        })
      );

      return ticketsWithDetails;
    },
  });
}

export function useTicketsByEntity(entityTable: string, entityId: string) {
  return useTickets({ entityTable, entityId });
}

export function useTicketStatusCounts() {
  return useQuery({
    queryKey: ['tickets', 'status-counts'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('tickets')
        .select('status');
      
      if (error) throw error;

      const counts = {
        open: 0,
        in_progress: 0,
        waiting: 0,
        resolved: 0,
        closed: 0,
        total: data?.length || 0,
      };

      data?.forEach((ticket) => {
        if (ticket.status in counts) {
          counts[ticket.status as keyof typeof counts]++;
        }
      });

      return counts;
    },
  });
}

export function useOpenTicketCount() {
  const { data } = useTicketStatusCounts();
  return (data?.open || 0) + (data?.in_progress || 0) + (data?.waiting || 0);
}

export function useCreateTicket() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (ticket: TicketInsert) => {
      // Note: ticket_number is auto-generated by a database trigger, so we don't include it
      const insertData = {
        title: ticket.title,
        description: ticket.description,
        entity_table: ticket.entity_table,
        entity_id: ticket.entity_id,
        ticket_type: ticket.ticket_type,
        priority: ticket.priority,
        status: ticket.status,
        assigned_to: ticket.assigned_to,
        due_date: ticket.due_date,
        created_by: ticket.created_by,
      };
      
      const { data, error } = await supabase
        .from('tickets')
        .insert(insertData as any)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
      toast({ title: 'Ticket created successfully' });
    },
    onError: (error) => {
      toast({
        title: 'Failed to create ticket',
        description: error.message,
        variant: 'destructive',
      });
    },
  });
}

export function useUpdateTicket() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: TicketUpdate }) => {
      // If status is being set to resolved, also set resolved_at
      if (updates.status === 'resolved' && !updates.resolved_at) {
        updates.resolved_at = new Date().toISOString();
      }

      const { data, error } = await supabase
        .from('tickets')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
      toast({ title: 'Ticket updated successfully' });
    },
    onError: (error) => {
      toast({
        title: 'Failed to update ticket',
        description: error.message,
        variant: 'destructive',
      });
    },
  });
}

export function useDeleteTicket() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('tickets')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
      toast({ title: 'Ticket deleted successfully' });
    },
    onError: (error) => {
      toast({
        title: 'Failed to delete ticket',
        description: error.message,
        variant: 'destructive',
      });
    },
  });
}

export function useUpdateTicketStatus() {
  const updateTicket = useUpdateTicket();

  return useMutation({
    mutationFn: async ({ id, status }: { id: string; status: TicketStatus }) => {
      return updateTicket.mutateAsync({ id, updates: { status } });
    },
  });
}
